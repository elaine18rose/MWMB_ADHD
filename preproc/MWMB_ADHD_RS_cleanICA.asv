%%
clear all;
close all;

%%
if isempty(findstr(pwd,'thandrillon'))==0
    path_fieldtrip='/Users/thandrillon/WorkGit/projects/ext/fieldtrip/';
    path_LSCPtools='/Users/thandrillon/WorkGit/LSCPtools/';
    path_data='/Users/thandrillon/Data/ADHD_MW/';
else
    path_LSCPtools = '/Users/elaine/desktop/MATLAB_Functions/LSCPtools/';
    path_fieldtrip = '/Users/elaine/Desktop/MATLAB_Functions/fieldtrip/';
    path_data = '/Volumes/Seagate/MWMB_ADHD_SART/';
end

addpath((path_fieldtrip));
%addpath(genpath(fullfile('/Users/elaine/Desktop/MATLAB_Functions/fieldtrip'))) %Demetrio 
ft_defaults;
addpath(genpath(path_LSCPtools))

files=dir([path_data filesep 'EEG' filesep '*_R*.eeg']);

%% loop on subjects
redo=1; % 1 to force re-import, 0 otherwise
for nF=1:length(files)
    if startsWith(files(nF).name, '._') % EP - Skip this file if it starts with dot underline.
        continue; %  EP - Jump to the bottom of the loop.
    end
    file_name = files(nF).name;
    folder_name = files(nF).folder;
    SubID=file_name(1:end-4);
    if isempty(findstr(SubID,'ID-'))==0
        SubID(1:findstr(SubID,'ID-')+2)=[];
    end
    FileNameID=SubID;
    if isempty(findstr(SubID,'_R'))==0
        SubID(findstr(SubID,'_R'):end)=[];
    end
    tic;
    %     if ~strcmp(SubID,'A084') %%re-add this if you need to clip the data
    %         continue;
    %     end
    fprintf('... working on %s (%g/%g)\n',file_name,nF,length(files))
    
    if redo==1 || exist([path_data filesep 'Preproc' filesep 'feRS_ft_' FileNameID '.mat'])==0
        
        %%% minimal preprocessing
        cfg=[];
        cfg.SubID          = SubID;
        cfg.dataset        = [files(nF).folder filesep files(nF).name];


        cfg.demean         = 'yes';
        cfg.lpfilter       = 'yes';        % enable low-pass filtering
        cfg.lpfilttype     = 'but';
        cfg.lpfiltord      = 4;
        cfg.lpfreq         = 40;
        cfg.hpfilter       = 'yes';        % enable high-pass filtering
        cfg.hpfilttype     = 'but';
        cfg.hpfiltord      = 4;
        cfg.hpfreq         = 1; %!!! Filtering at 1Hz to improve the ICA decomposition
        cfg.dftfilter      = 'yes';        % enable notch filtering to eliminate power line noise
        cfg.dftfreq        = [50 100];     % set up the frequencies for notch filtering

        cfg.reref          = 'yes';
        cfg.refchannel     = 'all';

        data               = ft_preprocessing(cfg); % read raw data

        cfg.hpfreq         = 0.1; %
        data_eeg               = ft_preprocessing(cfg); % read raw data

        cfg.length  = 10; % Length of each epoch in seconds
cfg.overlap = 0;  % No overlap between epochs
        data_epoched = ft_redefinetrial(cfg, data);

        %%% rename channels
        mylabels = data.label;
        for nCh = 1:length(mylabels)
            findspace = findstr(mylabels{nCh},' ');
            if isempty(findspace)
                newlabels{nCh} = mylabels{nCh};
            else
                if ismember(mylabels{nCh}(1),{'1','2','3','4','5','6','7','8','9'})
                    newlabels{nCh} = mylabels{nCh}(findspace+1:end);
                else
                    newlabels{nCh} = mylabels{nCh}(1:findspace-1);
                end
            end
        end
        cfg=[];
        cfg.channel          = data.label; %hdr.label(find((cellfun(@isempty,regexp(hdr.label,'EOG'))) & (cellfun(@isempty,regexp(hdr.label,'EMG'))) & (cellfun(@isempty,regexp(hdr.label,'ECG'))) & (cellfun(@isempty,regexp(hdr.label,'Mic')))));
        cfg.montage.labelold = data.label;
        cfg.montage.labelnew = newlabels;
        cfg.montage.tra      = eye(length(data.label));
        data = ft_preprocessing(cfg, data); %causing an error because they're mutually exclusive

        % Automating removal of noisy channels
        std_vec = [];
        kurt_vec = [];
        for k = 1:length(data.trial)
            std_vec =[std_vec log(std(data.trial{k},[],2))];
            kurt_vec =[kurt_vec log(kurtosis(data.trial{k},[],2))];
        end
        all_std_vec = (reshape(std_vec,1,numel(std_vec)));
        all_kurt_vec = (reshape(kurt_vec,1,numel(kurt_vec)));
        all_std_vec_frontal = (reshape(std_vec(find_trials(newlabels,'F*'),:),1,numel(std_vec(find_trials(newlabels,'F*'),:))));
        all_kurt_vec_frontal = (reshape(kurt_vec(find_trials(newlabels,'F*'),:),1,numel(kurt_vec(find_trials(newlabels,'F*'),:))));
        all_std_vec_nonfront = (reshape(std_vec(setdiff(1:length(newlabels),find_trials(newlabels,'F*')),:),1,numel(std_vec(setdiff(1:length(newlabels),find_trials(newlabels,'F*')),:))));
        all_kurt_vec_nonfront = (reshape(kurt_vec(setdiff(1:length(newlabels),find_trials(newlabels,'F*')),:),1,numel(kurt_vec(setdiff(1:length(newlabels),find_trials(newlabels,'F*')),:))));

        thr_badElec_std=(mean(all_std_vec_nonfront)+3*std(all_std_vec_nonfront))*ones(length(newlabels),length(data.trial));
        thr_badElec_std(find_trials(newlabels,'F*'),:)=mean(all_std_vec_frontal)+3*std(all_std_vec_frontal);
        thr_badElec_kurt=(mean(all_kurt_vec_nonfront)+3*std(all_kurt_vec_nonfront))*ones(length(newlabels),length(data.trial));
        thr_badElec_kurt(find_trials(newlabels,'F*'),:)=mean(all_kurt_vec_frontal)+3*std(all_kurt_vec_frontal);
        badCh_std_mat = (std_vec>thr_badElec_std);
        badCh_kur_mat = (kurt_vec>thr_badElec_kurt);

        % we can define a bad channel as a channel with more than 50% of
        % probes above the threshold
        badCh_std=find(mean(badCh_std_mat')>0.5);
        badCh_kur=find(mean(badCh_kur_mat')>0.5);
        badCh=find(mean(((badCh_std_mat+badCh_kur_mat)~=0)')>0.5);
        % we can define a bad epoch as an epoch in which more than 20% of
        % channels are above threshold
        % probes above the threshold
        badTr_std=find(mean(badCh_std_mat)>0.2);
        badTr_kur=find(mean(badCh_kur_mat)>0.2);
        badTr=find(mean(((badCh_std_mat+badCh_kur_mat)~=0))>0.2);
        %
        if strcmp(SubID, 'C017')==1 %EP
            badCh = [badCh 17]; %This is forcing an interpolation of TP9 by adding it into the vector
        end
        badChannels=badCh;
        badTrials=badTr;

        nFc=nFc+1;
        badChannels_badTrials_info{nFc,1}=SubID;
        badChannels_badTrials_info{nFc,2}=badCh_std;
        badChannels_badTrials_info{nFc,3}=badCh_kur;
        badChannels_badTrials_info{nFc,4}=badChannels;
        badChannels_badTrials_info{nFc,5}=badTr_std;
        badChannels_badTrials_info{nFc,6}=badTr_kur;
        badChannels_badTrials_info{nFc,7}=badTrials;

        fprintf('Processing %s\n', SubID); % EP - debugging to check which participant is being processed
        disp(badChannels_badTrials_info(:, 1)); % EP - debugging to see if variable is being updated

        if ~isempty(badChannels)
            fprintf('... ... interpolating %g channels\n',length(badChannels))
            % find neighbours
            cfg=[];
            cfg.method        = 'triangulation';
            cfg.layout        = layout;
            cfg.feedback      = 'no';
            cfg.channel = layout.label;
            [neighbours] = ft_prepare_neighbours(cfg);

            % interpolate channels
            cfg=[];
            cfg.method         = 'weighted';
            cfg.badchannel     = layout.label(badChannels);
            cfg.missingchannel = [];
            cfg.neighbours     = neighbours;
            cfg.trials         = 'all';
            cfg.layout         = layout;
            cfg.channel = layout.label;
            [data] = ft_channelrepair(cfg, data); %crashing here
        end

        cfg=[];
        cfg.reref      = 'yes';
        cfg.refchannel = 'all';
        data = ft_preprocessing(cfg,data);

        if ~isempty(badTrials)
            cfg=[];
            cfg.trials    = setdiff(1:length(data.trial),badTrials);
            data = ft_redefinetrial(cfg,data);
        end

        EEG = fieldtrip2eeglab(data);
        EEG = pop_chanedit(EEG, 'lookup', fullfile(path_eeglab, 'plugins', 'dipfit', 'standard_BESA', 'standard-10-5-cap385.elp'));
        EEG = eeg_checkset(EEG); %This checks if current channel no. has the same amount as channel locations. If not, it deletes channel locations
        EEG_ica = pop_runica(EEG, 'icatype', 'runica'); %Runs ICA
        EEG_icalabels = pop_iclabel(EEG_ica,'default'); %Automates detectio of bad ICA components


        ICA_classification=EEG_icalabels.etc.ic_classification.ICLabel.classifications;
        ICA_classification=array2table(ICA_classification,'VariableNames',EEG_icalabels.etc.ic_classification.ICLabel.classes);

        ICA_classification.SubID=nan(size(ICA_classification,1),1);
        ICA_classification.SubID=categorical(ICA_classification.SubID);
        ICA_classification.SubID=repmat(SubID,size(ICA_classification,1),1);
        ICA_classification.Comp=(1:size(ICA_classification,1))';

        save([preproc_path filesep 'comp_i_probe_' SubID],'EEG_ica','EEG_icalabels','ICA_classification')
        all_ICA_classification=[all_ICA_classification ; ICA_classification]; %EP - moved this

        run('../MWMB_ADHD_elec_layout.m') % EP - moved this
        figure('visible','off');
        for nComp=1:16% size(EEG_ica.icawinv,2)
            subplot(4,4,nComp)
            simpleTopoPlot_ft(EEG_ica.icawinv(:,nComp), layout,'on',[],0,1); colorbar;
            [maxValue, maxIndex] = max(table2array(ICA_classification(nComp, 1:7))); %EP
            thisLabel = ICA_classification.Properties.VariableNames{maxIndex};
            %thisLabel=ICA_classification.Properties.VariableNames(find(table2array(ICA_classification(nComp,1:7))==max(table2array(ICA_classification(nComp,1:7)))));
            title(sprintf('%s: %1.3f', thisLabel, maxValue));
            %title(sprintf('%s: %1.3f',thisLabel{1},max(table2array(ICA_classification(nComp,:)))));
        end
        savefig(gcf,[preproc_path filesep 'comp_i_probe_' SubID '.fig'])
        close(gcf)

        
    end
    toc;
end


