%% Init
clear all;
close all;
%%
if isempty(findstr(pwd,'thandrillon'))==0
    path_LSCPtools='/Users/tand0009/WorkGit/LSCPtools/';
    path_fieldtrip='/Users/thandrillon/WorkGit/projects/ext/fieldtrip/';
    data_path='/Users/thandrillon/Data/ADHD_MW/EEG/';
    preproc_path='/Users/thandrillon/Data/ADHD_MW/Preproc/';
    path_eeglab='/Users/thandrillon/WorkGit/projects/ext/eeglab/';
    path_ICAlabel='/Users/thandrillon/WorkGit/projects/ext/ICLabel/';
else
    path_LSCPtools = '/Users/elaine/desktop/MATLAB_Functions/LSCPtools/';
    path_fieldtrip = '/Users/elaine/desktop/MATLAB_Functions/fieldtrip/';
    data_path = '/Volumes/Seagate/MWMB_ADHD_SART/EEG/';
    preproc_path='/Volumes/Seagate/MWMB_ADHD_SART/preproc/';
    path_detectSW = '/Volumes/Seagate/MWMB_ADHD_SART/SW_detection/';
    path_eeglab='/Users/elaine/desktop/MATLAB_Functions/eeglab/';
    path_ICAlabel='/Users/elaine/desktop/MATLAB_Functions/ICLabel/';

    %     mkdir(path_detectSW)
end
% adding relevant toolboxes to the path
% spm12 and LSCPtools
addpath(genpath(path_LSCPtools))
addpath(path_fieldtrip)
ft_defaults;
addpath(path_eeglab);
eeglab;

% select relevant files, here task 
eeg_files=dir([data_path filesep '*.eeg']);

%EEG Layout info
run ../MWMB_ADHD_elec_layout.m


%% Loop across files
RS = ["R1", "R2"];

redo=1;

for nF=1:length(eeg_files)
    if startsWith(eeg_files(nF).name, '._') % EP - Skip this file if it starts with dot underline.
        continue; %  EP - Jump to the bottom of the loop.
    end

    if contains(eeg_files(nF).name,RS) %To skip resting state files
        continue
    end

    %%% load the data
    SubInfo=split(eeg_files(nF).name,'-');
    SubID=SubInfo{2};

    if redo==1 || exist([preproc_path filesep 'comp2i_' SubID(1:end-4) '.mat'])==0 % To skip already preprocessed files
        fprintf('... working on %s\n',[eeg_files(nF).name])

        %%% minimal preprocessing
        cfg=[];
        cfg.SubID          = SubID;
        cfg.dataset        = [eeg_files(nF).folder filesep eeg_files(nF).name];


        cfg.demean         = 'yes';
        cfg.lpfilter       = 'yes';        % enable high-pass filtering
        cfg.lpfilttype     = 'but';
        cfg.lpfiltord      = 4;
        cfg.lpfreq         = 40;
        cfg.hpfilter       = 'yes';        % enable high-pass filtering
        cfg.hpfilttype     = 'but';
        cfg.hpfiltord      = 4;
        cfg.hpfreq         = 1; %!!! Filtering at 1Hz to improve the ICA decomposition
        cfg.dftfilter      = 'yes';        % enable notch filtering to eliminate power line noise
        cfg.dftfreq        = [50 100];     % set up the frequencies for notch filtering

        cfg.reref          = 'yes';
        cfg.refchannel     = 'all';

        cfg.trialfun            = 'MWMB_ADHD_probefun';
%         cfg.table               = table;
        cfg.SubID               = SubID;
        cfg.dataset             = [eeg_files(nF).folder filesep eeg_files(nF).name];
        cfg.trialdef.prestim    = 25;
        cfg.trialdef.poststim   = 2;
        cfg = ft_definetrial(cfg);

        data               = ft_preprocessing(cfg); % read raw data

        %%% rename channels
        mylabels = data.label;
        for nCh = 1:length(mylabels)
            findspace = findstr(mylabels{nCh},' ');
            if isempty(findspace)
                newlabels{nCh} = mylabels{nCh};
            else
                if ismember(mylabels{nCh}(1),{'1','2','3','4','5','6','7','8','9'})
                    newlabels{nCh} = mylabels{nCh}(findspace+1:end);
                else
                    newlabels{nCh} = mylabels{nCh}(1:findspace-1);
                end
            end
        end
        cfg=[];
        cfg.channel          = data.label; %hdr.label(find((cellfun(@isempty,regexp(hdr.label,'EOG'))) & (cellfun(@isempty,regexp(hdr.label,'EMG'))) & (cellfun(@isempty,regexp(hdr.label,'ECG'))) & (cellfun(@isempty,regexp(hdr.label,'Mic')))));
        cfg.montage.labelold = data.label;
        cfg.montage.labelnew = newlabels;
        cfg.montage.tra      = eye(length(data.label));
        data = ft_preprocessing(cfg, data); %causing an error because they're mutually exclusive

        % Automating removal of noisy channels
        std_vec = [];
        kurt_vec = [];
        for k = 1:length(data.trial)
        std_vec =[std_vec log(std(data.trial{k},[],2))];
        kurt_vec =[kurt_vec log(kurtosis(data.trial{k},[],2))];
        end
        all_std_vec = (reshape(std_vec,1,numel(std_vec)));
        all_kurt_vec = (reshape(kurt_vec,1,numel(kurt_vec)));
        badCh_std_mat = (std_vec>(mean(all_std_vec)+3*std(all_std_vec)));
        badCh_kur_mat = (kurt_vec>(mean(all_kurt_vec)+3*std(all_kurt_vec)));

        % we can define a bad channel as a channel with more than 50% of
        % probes above the threshold
        badCh_std=find(mean(badCh_std_mat')>0.5);
        badCh_kur=find(mean(badCh_kur_mat')>0.5);

        % we can define a bad epoch as an epoch in which more than 20% of
        % channels are above threshold
        % probes above the threshold
        badTr_std=find(mean(badCh_std_mat)>0.2);
        badTr_kur=find(mean(badCh_kur_mat)>0.2);

        %
        badChannels=unique([badCh_std ; badCh_kur]);
        badChannels_badTrials_info{nF,1}=SubID;
        badChannels_badTrials_info{nF,2}=badCh_std;
        badChannels_badTrials_info{nF,3}=badCh_kur;
        badChannels_badTrials_info{nF,4}=badTr_std;
        badChannels_badTrials_info{nF,5}=badTr_kur;
        if ~isempty(badChannels)
            fprintf('... ... interpolating %g channels\n',length(badChannels))
            % find neighbours
            cfg=[];
            cfg.method        = 'triangulation';
            cfg.layout        = layout;
            cfg.feedback      = 'no';
            cfg.channel = layout.label;
            [neighbours] = ft_prepare_neighbours(cfg);

            % interpolate channels
            cfg=[];
            cfg.method         = 'weighted';
            cfg.badchannel     = layout.label(badChannels);
            cfg.missingchannel = [];
            cfg.neighbours     = neighbours;
            cfg.trials         = 'all';
            cfg.layout         = layout;
            cfg.channel = layout.label;
            [data] = ft_channelrepair(cfg, data); %crashing here
        end

        cfg=[];
        cfg.reref      = 'yes';
        cfg.refchannel = 'all';
        data = ft_preprocessing(cfg,data);

        cfg=[];
        cfg.trialfun            = 'MWMB_ADHD_probefun';
        cfg.dataset             = [eeg_files(nF).folder filesep eeg_files(nF).name];
        cfg.trialdef.prestim    = 30;
        cfg.trialdef.poststim   = 0;
        cfg = ft_definetrial(cfg);
        data = ft_preprocessing(cfg,data);

        EEG = fieldtrip2eeglab(data);
        eloc = readlocs([path_fieldtrip '/template/layout/acticap-64ch-standard2.mat']); %%eloc = readlocs('chanlocs.ced'); % Channel location - right now it's 28 channels when we need 64
        % need to fix line above to make it more streamlined
        toRemove = false(1, length(eloc));
        for nCh = 1:length(eloc)
            if contains(eloc(nCh).labels,'Gnd')|| contains(eloc(nCh).labels,'Ref')
                toRemove(nCh) = true;
            end
        end
        eloc(toRemove) = []; %Remove Grnd and Ref electrodes

        EEG.chanlocs=eloc;
        EEG = eeg_checkset(EEG); %This checks if current channel no. has the same amount as channel locations. If not, it deletes channel locations
        EEG_ica = pop_runica(EEG, 'icatype', 'runica'); %Runs ICA
        EEG_icalabels = pop_iclabel(EEG_ica,'default'); %Automates detectio of bad ICA components


        ICA_classification=EEG_icalabels.etc.ic_classification.ICLabel.classifications;
        ICA_classification=array2table(ICA_classification,'VariableNames',EEG_icalabels.etc.ic_classification.ICLabel.classes);
        save([preproc_path filesep 'comp2i_' eeg_files(nF).name],'EEG_icalabels','ICA_classification')


        %%% run ICA through field trip - not needed here since we're running ICA through EEGlab
        %         rankICA = rank(data.trial{1,1});
        %         cfg        = [];
        %         cfg.method = 'runica'; % this is the default and uses the implementation from EEGLAB
        %         cfg.numcomponent = rankICA;
        %         comp = ft_componentanalysis(cfg, data);


        rejected_comps = find(EEG.reject.gcompreject > 0);
        EEG = pop_subcomp(EEG, rejected_comps);
        EEG = eeg_checkset(EEG);

%         % convert back to Fieldtrip
%         curPath = pwd;
%         p = fileparts(which('ft_read_header'));
%         cd(fullfile(p, 'private'));
%         hdr = read_eeglabheader( EEG );
%         data = read_eeglabdata( EEG, 'header', hdr );
%         event = read_eeglabevent( EEG, 'header', hdr );
% 
%         OUTEEG = pop_subcomp( EEG, components, plotag);
% 
%         EEG_icalabels = pop_iclabel(EEG_ica,'default');
% 
%         %defining epochs - moved this after ICA because the script wasn't
%         %running due to diff trial numbers per block
%         cfg                     = [];
%         cfg.trialfun            = 'MWMB_ADHD_blockfun';
%         cfg.trialdef.prestim    = 1;
%         cfg.trialdef.poststim   = 1;
%         cfg                     = ft_definetrial(cfg);
% 
%         save([preproc_path filesep 'Icfe_MWADHD_' SubID(1:end-4) '.mat'],'data','comp','rankICA','badChannels');
    end
end
